import numpy as np
import vish_graphs as vg
import pandas as pd
import torch
import torch.nn as nn
import torch.optim as optim
from torch.utils.data import Dataset, DataLoader
import core_rec as cs

# Load the CSV file into a DataFrame
adj_matrix = np.loadtxt('adj.csv', delimiter=",")
wgt_matrix = np.loadtxt('label.csv', delimiter=",")

# Load node labels
df = pd.read_csv("labelele.csv")
col = df.values.flatten()
node_labels = {i: label for i, label in enumerate(col)}

# Find top nodes
top_nodes = vg.find_top_nodes(adj_matrix, 4)

# ML
# Convert adjacency matrix to dataset
graph_dataset = cs.GraphDataset(adj_matrix)
data_loader = DataLoader(graph_dataset, batch_size=5, shuffle=True)

# Define model parameters
num_layers = 2
d_model = 128
num_heads = 8
d_feedforward = 512
input_dim = len(adj_matrix[0])

# Initialize model, loss function, and optimizer
model = cs.GraphTransformer(num_layers, d_model, num_heads, d_feedforward, input_dim, use_weights=True)
criterion = nn.MSELoss()
optimizer = optim.Adam(model.parameters(), lr=0.001)
top_nodes = vg.find_top_nodes(adj_matrix, num_nodes=5)

# Train the model
num_epochs = 1000
cs.train_model(model, data_loader, criterion, optimizer, num_epochs)

# Predict recommendations for a specific node
node_index =5    # target node
recommended_nodes = cs.predict(model, adj_matrix, node_index, top_k=5, threshold=1.0)

# Convert recommended node indices to labels
recommended_labels = [node_labels[node] for node in recommended_nodes]
print(f"Recommended nodes for node {node_labels[node_index]}: {recommended_labels}")
torch.save(model.state_dict(), 'qwertyu.pth')

# Draw the graph with labels
# vg.draw_graph_3d(adj_matrix, node_labels=node_labels, top_nodes=top_nodes, transparent_labeled=False, edge_weights=wgt_matrix)